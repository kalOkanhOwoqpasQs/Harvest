for i, bot in pairs(getBots()) do
    if getBot().name:upper() == bot.name:upper() then
        param = i
    end
end

mode = bot[param].mode
startfrom = bot[param].startfrom
slot = bot[param].slot
farmList = bot[param].farmList
idList = bot[param].idList
webhook = bot[param].webhooktask.link
message = bot[param].webhooktask.messageid
index = 1
local tilePack = 0
local tileBlock = 0
local tileSeed = 0
local tileEvent = 0
infoid = {}
timer = {}
trees = {}
local identity = {}
identity.param = idList
identity.goodtime = os.time()
seedX = setting.storage.seed.drop.x - 1
seedY = setting.storage.seed.drop.y - 1
packX = setting.storage.pack.drop.x - 1
packY = setting.storage.pack.drop.y - 1
blockX = setting.storage.block.drop.x - 1
blockY = setting.storage.block.drop.y - 1
eventX = setting.storage.event.drop.x - 1
eventY = setting.storage.event.drop.y - 1
strings = ""

identity.recycles = function()
    if findItem(setting.item.block) > 0 then
        sendPacket("action|trash\n|itemID|" .. setting.item.block,2)
        sleep(2000)
        sendPacket("action|dialog_return\ndialog_name|trash_item\nitemID|" .. setting.item.block .. "|\ncount|" .. findItem(setting.item.block),2)
        sleep(2000)
    end
end

identity.round = function(n)
    return n % 1 > 0.5 and math.ceil(n) or math.floor(n)
end

identity.splitt = function(str, ptr)
    if not ptr then 
        ptr = "%s"
    end
    local tbl = {}
    for string in string.gmatch(str, ptr) do
        table.insert(tbl, string) 
    end
    return tbl
end

identity.hookblock = function()
    strings = ""
	for i = 1, #setting.storage.block.world do
		strings = strings.."\n[ ||"..string.upper(setting.storage.block.world[i]).."|| ] "..(infoid[setting.storage.block.world[i]] or "?")..""
    end
    return strings
end

identity.hookseed = function()
    strings = ""
	for i = 1, #setting.storage.seed.world do
		strings = strings.."\n[ ||"..string.upper(setting.storage.seed.world[i]).."|| ] "..(infoid[setting.storage.seed.world[i]] or "?")..""
    end
    return strings
end

identity.hookpack = function()
    strings = ""
	for i = 1, #setting.storage.pack.world do
		strings = strings.."\n[ ||"..string.upper(setting.storage.pack.world[i]).."|| ] "..(infoid[setting.storage.pack.world[i]] or "?")..""
    end
    return strings
end

identity.hookevent = function()
    strings = ""
	for i = 1, #setting.storage.event.world do
		strings = strings.."\n[ ||"..string.upper(setting.storage.event.world[i]).."|| ] "..(infoid[setting.storage.event.world[i]] or "?")..""
    end
    return strings
end

identity.farmname = function()
    strings = ""
	for i = 1, #farmList do
		strings = strings.."\n||"..string.upper(farmList[i]).."||"
	end
	return strings
end

identity.farmestimate =  function()
    strings = ""
	for i = 1, #farmList do
		strings = strings.."\n"..(timer[farmList[i]] or "?")..""
    end
    return strings
end

identity.treesworld = function()
    strings = ""
	for i = 1, #farmList do
		strings = strings.."\n"..(trees[farmList[i]] or "?")..""
	end
	return strings
end

identity.webhookinfo = function(info)
	if setting.webhook.access then
        local text = [[
            $webHookUrl = "]]..webhook..[[/messages/]]..message..[["
            $payload = @{
                username = "BizzantiuM's"
                embeds = @(
                    @{
                        title = "AUTO HARVEST v1.0[]]..string.upper(setting.typeMode)..[[]"
                        color = "]]..math.random(111111,999999)..[["
                        fields = @(
                            @{
                                name = ""
                                value = "]].."RUNNING : [ "..identity.goodtimes(os.difftime(os.time(),identity.goodtime)).." ]"..[["
                                inline = "false"
                            }
                            @{
                                name = "BOT INFORMATION []]..slot..[[]"
                                value = "]].."TASK : "..info.."\nNAME : [ ||"..getBot().name.."|| ]\nCURRENT : [ ||"..getBot().world.."|| ]\nLEVEL : [ "..getBot().level.." ]\nSTATUS : [ "..string.upper(getBot().status).." ]\nGEMS : [ "..getBot().gems.."]"..[["
                                inline = "false"
                            }
                            @{
                                name = "STORAGE STATIC"
                                value = "]]..""..[["
                                inline = "false"
                            }
                            @{
                                name = "BLOCK"
                                value = "]]..identity.hookblock()..[["
                                inline = "false"
                            }
                            @{
                                name = "SEED"
                                value = "]]..identity.hookseed()..[["
                                inline = "true"
                            }
                            @{
                                name = "PACK"
                                value = "]]..identity.hookpack()..[["
                                inline = "true"
                            }
                            @{
                                name = "EVENT"
                                value = "]]..identity.hookevent()..[["
                                inline = "true"
                            }
                            @{
                                name = "WORLD STATIC"
                                value = "]]..""..[["
                                inline = "false"
                            }
                            @{
                                name = "FARM"
                                value = "]]..identity.farmname()..[["
                                inline = "true"
                            }
                            @{
                                name = "TREE READY"
                                value = "]]..identity.treesworld()..[["
                                inline = "true"
                            }
                            @{
                                name = "ESTIMATE"
                                value = "]]..identity.farmestimate()..[["
                                inline = "true"
                            }
                        )
                        footer = @{
                            text = "Developed by BizzantiuM's`nLast updated : ]]..(os.date"%d/%m/%y":upper().." at ")..os.date("%I")..":"..os.date("%M").." "..os.date("%p"):upper()..[["
                        }
                    }
                )
            }
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Patch -ContentType 'application/json'
        ]]
        local pipe = io.popen("powershell -command -", "w")
        pipe:write(text)
        pipe:close()
    end
end

identity.botinfo = function(text)
    if setting.webhook.access then
        text = [[
            $webHookUrl = "]]..setting.webhook.status..[["
            $payload = @{
                content = "]]..text..[["
            }
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Post -ContentType "application/json"
        ]]
        local file = io.popen("powershell -command -", "w")
        file:write(text)
        file:close()
    end
end

identity.goodtimes = function(estimates)
    local seconds = tonumber(estimates)
    if seconds <= 0 then
        return "00:00:00";
    else
        hours = string.format("%02.f", math.floor(estimates/3600));
        minutes = string.format("%02.f", math.floor(estimates/60 - (hours*60)));
        seconds = string.format("%02.f", math.floor(estimates - hours*3600 - minutes *60));
        return ""..hours.." : "..minutes.." : "..seconds
    end
end

identity.checker = function(world)
    while getBot().world ~= string.upper(world) and not nuked do
        sendPacket("action|join_request\nname|"..world.."\ninvitedWorld|0",3)
        sleep(setting.delay.warp)
    end
end

identity.warp = function(world,door)
    name = world
    door = identity.door
    if identity.door then
        name = name .. "|" ..identity.door
    end
    if getBot().world ~= string.upper(world) then
        addHook("onvariant","nuked",function (varlist)
            if varlist[0] == "OnConsoleMessage" then
                if string.find(varlist[1],"inaccessible.") then
                    nuked = true
                end
            end
        end)
        while getBot().world ~= string.upper(world) and not nuked do
            sendPacket("action|join_request\nname|"..name.."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        removeHooks()
        sleep(1000)
    end
    if identity.door and getBot().world == string.upper(world) then
        local stuck = 0
        while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 and not wrong do
            sendPacket("action|join_request\nname|"..name.."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

identity.reconnect = function(world,id,x,y)
    if getBot().world == "EXIT" then 
        identity.botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." stuck EXIT ??, trying to joining world again @everyone")
        print("[ "..getBot().name.." ] slot : "..slot.." stuck EXIT ??, trying to joining world again")
        while getBot().world ~= world:upper() do
            sendPacket("action|join_request\nname|"..world:upper().."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        if id ~= "" then
            while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
                sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
                sleep(setting.delay.warp)
            end
        end
        if x and y then
            while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                findPath(x,y)
                sleep(100)
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." success to joining world @everyone")
        print("[ "..getBot().name.." ] slot : "..slot.." success to joining world")
    end
    while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
        identity.botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." back to white door, what happened?! trying back to position")
        print("[ "..getBot().name.." ] slot : "..slot.." back to white door, what happened?! trying back to position")
        sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
        sleep(setting.delay.warp)
        if x and y then
            while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                findPath(x,y)
                sleep(100)
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." already back to position")
        print("[ "..getBot().name.." ] slot : "..slot.." already back to position")
    end
    if getBot().status ~= "online" then
        identity.botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." status is "..getBot().status.." @everyone")
        print("[ "..getBot().name.." ] slot : "..slot.." status is "..getBot().status.."")
        while getBot().status ~= "online" do
            connect()
            sleep(setting.delay.reconnect)
            if getBot().status == "suspended" or getBot().status == "banned" or getBot().status == "ercon" then
                botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." status is "..getBot().status..", removing bot @everyone")
                print("[ "..getBot().name.." ] slot : "..slot.." status is "..getBot().status..", removing bot")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
        end
        while getBot().world ~= world:upper() do
            sendPacket("action|join_request\nname|"..world:upper().."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        if id ~= "" then
            while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
                sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
                sleep(setting.delay.warp)
            end
        end
        if x and y then
            while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                findPath(x,y)
                sleep(150)
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." status is "..getBot().status.." @everyone")
        print("[ "..getBot().name.." ] slot : "..slot.." status is "..getBot().status.."")
    end
end

identity.itemFloat = function(id)
	local count = 0
	for _, obj in pairs(getObjects()) do
		if obj.id == id then
			count = count + obj.count
		end
	end
	return count
end

identity.randomworld = function(threads)
    setJob("Clearing history")
    identity.webhookinfo("Clearing world history")
    for _, tableworld in pairs(setting.mode.world) do
        identity.checker(tableworld)
        sleep(setting.delay.warp)
    end
end

identity.buying = function(threads)
    if findItem(112) >= setting.pack.mingems then
        while findItem(112) >= setting.pack.mingems do
            while getBot().slots < 36 do
                sendPacket("action|buy\nitem|upgrade_backpack",2)
                sleep(1000)
            end
            while findItem(112) > setting.pack.price do
                sendPacket("action|buy\nitem|"..setting.pack.debug,2)
                sleep(1000)
                if findItem(setting.pack.packList[1]) >= 200 then
                    break
                end
            end
        end
    end
end

identity.storingevents = function(threads)
    for i = index , #setting.storage.event.world do
        setJob("Dropping events")
        world = setting.storage.event.world[i]
        identity.door = setting.storage.event.door
        identity.warp(world,identity.door)
        identity.webhookinfo("Dropping events")
        if not nuked then
            if not wrong then
                if identity.itemFloat(setting.item.event[1]) >= setting.storage.event.limit then
                    infoid[world] = "["..identity.itemFloat(setting.item.event[1]).."] LIMIT !!!"
                    identity.botinfo("Events storage : [ ||"..getBot().world.."|| ] has reached limit, skipped world @everyone")
                    print("Events storage : [ "..getBot().world.." ] has reached limit, skipped world")
                    index = index + 1
                    if index > #setting.storage.event.world then
                        infoid[world] = "["..identity.itemFloat(setting.item.event[1]).."] LIMIT !!!"
                        identity.botinfo("All events storage has reached limit, Removing bot : [ ||"..getBot().name.."|| ] slot : "..slot.." @everyone")
                        print("All events storage has reached limit, Removing bot : [ "..getBot().name.." ] slot : "..slot.."")
                        identity.webhookinfo("All events storage has reached limit, Removing bot!")
                        if setting.mode.removeBot then
                            removeBot(getBot().name)
                            sleep(100)
                        end
                        error()
                    end
                    tileEvent = 0
                else
                    for y,pack in pairs(setting.item.event) do
                        for i,tile in pairs(getTiles()) do
                            if setting.mode.separated then
                                if tile.fg == 0 or tile.bg == 0 then
                                    ::BACK::
                                    findPath(eventX + (tileEvent),eventY - (y - 1))
                                    sleep(1000)
                                    local count = 0
                                    identity.reconnect(world,identity.door,eventX + (tileEvent),eventY - (y - 1))
                                    if eventX + (tileEvent) >= 98 then
                                        eventY = eventY - 1
                                        tileEvent = 0
                                    end
                                    while findItem(pack) > 0 do
                                        drop(pack)
                                        sleep(setting.delay.drop)
                                        identity.reconnect(world,identity.door,eventX + (tileEvent),eventY - (y - 1))
                                        count = count + 1
                                        if count >= 2 then
                                            tileEvent = tileEvent + 1
                                            goto BACK
                                        end
                                    end
                                end
                                if findItem(pack) == 0 then
                                    break
                                end
                            else
                                if tile.fg == 0 or tile.bg == 0 then
                                    ::BACK::
                                    findPath(eventX + (tileEvent),eventY)
                                    sleep(1000)
                                    local count = 0
                                    identity.reconnect(world,identity.door,eventX + (tileEvent),eventY)
                                    if eventX + (tileEvent) >= 98 then
                                        eventY = eventY - 1
                                        tileEvent = 0
                                    end
                                    while findItem(pack) > 0 do
                                        drop(pack)
                                        sleep(setting.delay.drop)
                                        identity.reconnect(world,identity.door,eventX + (tileEvent),eventY)
                                        count = count + 1
                                        if count >= 2 then
                                            tileEvent = tileEvent + 1
                                            goto BACK
                                        end
                                    end
                                end
                                if findItem(pack) == 0 then
                                    break
                                end
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door events storage is wrong, check ur id door!")
                identity.botinfo("[ ||"..getBot().world.."|| ] Id door events storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.event.world then
                    print("All events storage has reached limit")
                    identity.botinfo("All events storage has reached limit! Removing bot : [ ||"..getBot().name.."|| ] slot : "..slot.." @everyone")
                    identity.webhookinfo("All events storage has reached limit, Removing bot!")
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
                tileEvent = 0
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] event Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] event Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.event.world then
                print("All events storage has reached limit!")
                identity.botinfo("All events storage has reached limit! Removing bot : [ ||"..getBot().name.."|| ] slot : "..slot.." @everyone")
                identity.webhookinfo("All events storage has reached limit, Removing bot!")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
            tileEvent = 0
        end
    end
    infoid[world] = "["..identity.itemFloat(setting.item.event[1]).."]"
    if setting.mode.clearhistory then
        identity.randomworld(threads)
    end
    setJob(string.upper(setting.typeMode))
end

identity.storingpacks = function(threads)
    for i = index , #setting.storage.pack.world do
        setJob("Dropping packs")
        world = setting.storage.pack.world[i]
        identity.door = setting.storage.pack.door
        identity.warp(world,identity.door)
        identity.webhookinfo("Dropping packs")
        if not nuked then
            if not wrong then
                if identity.itemFloat(setting.pack.packList[1]) >= setting.storage.pack.limit then
                    infoid[world] = "["..identity.itemFloat(setting.pack.packList[1]).."] LIMIT !!!"
                    identity.botinfo("Packs storage : [ ||"..getBot().world.."|| ] has reached limit, skipped world @everyone")
                    print("Packs storage : [ "..getBot().world.." ] has reached limit, skipped world")
                    index = index + 1
                    if index > #setting.storage.pack.world then
                        infoid[world] = "["..identity.itemFloat(setting.pack.packList[1]).."] LIMIT !!!"
                        identity.botinfo("All packs storage has reached limit, Removing bot : [ ||"..getBot().name.."|| ] slot : "..slot.." @everyone")
                        print("All packs storage has reached limit, Removing bot : [ "..getBot().name.." ] slot : "..slot.."")
                        identity.webhookinfo("All packs storage has reached limit, Removing bot!")
                        if setting.mode.removeBot then
                            removeBot(getBot().name)
                            sleep(100)
                        end
                        error()
                    end
                    tilePack = 0
                else
                    for y,pack in pairs(setting.pack.packList) do
                        for i,tile in pairs(getTiles()) do
                            if setting.mode.separated then
                                if tile.fg == 0 or tile.bg == 0 then
                                    ::BACK::
                                    findPath(packX + (tilePack),packY - (y-1))
                                    sleep(1000)
                                    local count = 0
                                    identity.reconnect(world,identity.door,packX + (tilePack),packY - (y-1))
                                    if packX + (tilePack) >= 98 then
                                        packY = packY - 1
                                        tilePack = 0
                                    end
                                    while findItem(pack) > 0 do
                                        drop(pack)
                                        sleep(setting.delay.drop)
                                        identity.reconnect(world,identity.door,packX + (tilePack),packY - (y-1))
                                        count = count + 1
                                        if count >= 2 then
                                            tilePack = tilePack + 1
                                            goto BACK
                                        end
                                    end
                                end
                                if findItem(pack) == 0 then
                                    break
                                end
                            else
                                if tile.fg == 0 or tile.bg == 0 then
                                    ::BACK::
                                    findPath(packX + (tilePack),packY)
                                    sleep(1000)
                                    local count = 0
                                    identity.reconnect(world,identity.door,packX + (tilePack),packY)
                                    if packX + (tilePack) >= 98 then
                                        packY = packY - 1
                                        tilePack = 0
                                    end
                                    while findItem(pack) > 0 do
                                        drop(pack)
                                        sleep(setting.delay.drop)
                                        identity.reconnect(world,identity.door,packX + (tilePack),packY)
                                        count = count + 1
                                        if count >= 2 then
                                            tilePack = tilePack + 1
                                            goto BACK
                                        end
                                    end
                                end
                                if findItem(pack) == 0 then
                                    break
                                end
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door packs storage is wrong, check ur id door!")
                identity.botinfo("[ ||"..getBot().world.."|| ] Id door packs storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.pack.world then
                    print("All packs storage has reached limit")
                    identity.botinfo("All packs storage has reached limit! Removing bot : [ ||"..getBot().name.."|| ] slot : "..slot.." @everyone")
                    identity.webhookinfo("All packs storage has reached limit, Removing bot!")
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
                tilePack = 0
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] packs Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] packs Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.pack.world then
                print("All packs storage has reached limit!")
                identity.botinfo("All packs storage has reached limit! Removing bot : [ ||"..getBot().name.."|| ] slot : "..slot.." @everyone")
                identity.webhookinfo("All packs storage has reached limit, Removing bot!")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
            tilePack = 0
        end
    end
    infoid[world] = "["..identity.itemFloat(setting.pack.packList[1]).."]"
    if setting.mode.clearhistory then
        identity.randomworld(threads)
    end
    setJob(string.upper(setting.typeMode))
end

identity.storingseeds = function(threads)
    for i = index , #setting.storage.seed.world do
        world = setting.storage.seed.world[i]
        identity.door = setting.storage.seed.door
        setJob("Dropping seeds")
        identity.warp(world,identity.door)
        identity.webhookinfo("Dropping seeds")
        if not nuked then
            if not wrong then
                if identity.itemFloat(setting.item.seed) >= setting.storage.seed.limit then
                    infoid[world] = "["..identity.itemFloat(setting.item.seed).."] LIMIT !!!"
                    identity.botinfo("Seeds storage : [ ||"..getBot().world.."|| ] has reached limit, skipped world @everyone")
                    print("Seeds storage : [ "..getBot().world.." ] has reached limit, skipped world")
                    index = index + 1
                    if index > #setting.storage.seed.world then
                        infoid[world] = "["..identity.itemFloat(setting.item.seed).."] LIMIT !!!"
                        identity.botinfo("All seeds storage has reached limit, Removing bot : [ ||"..getBot().name.."|| ] slot : "..slot.." @everyone")
                        print("All seeds storage has reached limit, Removing bot : [ "..getBot().name.." ] slot : "..slot.." @everyone")
                        identity.webhookinfo("All seeds storage has reached limit, Removing bot!")
                        if setting.mode.removeBot then
                            removeBot(getBot().name)
                            sleep(100)
                        end
                        error()
                    end
                    tileSeed = 0
                else
                    for i,tile in pairs(getTiles()) do
                        if tile.fg == 0 or tile.bg == 0 then
                            ::BACK::
                            findPath(seedX + (tileSeed),seedY)
                            sleep(1000)
                            local count = 0
                            identity.reconnect(world,identity.door,seedX + (tileSeed),seedY)
                            if seedX + (tileSeed) >= 98 then
                                seedY = seedY - 1
                                tileSeed = 0
                            end
                            while findItem(setting.item.seed) > 0 do
                                drop(setting.item.seed)
                                sleep(setting.delay.drop)
                                identity.reconnect(world,identity.door,seedX + (tileSeed),seedY)
                                count = count + 1
                                if count >= 2 then
                                    tileSeed = tileSeed + 1
                                    goto BACK
                                end
                            end
                        end
                        if findItem(setting.item.seed) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door seeds storage is wrong, check ur id door!")
                identity.botinfo("[ "..getBot().world.." ] Id door seeds storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.seed.world then
                    print("All seeds storage has reached limit")
                    identity.botinfo("All seeds storage has reached limit @everyone")
                    identity.webhookinfo("All seeds storage has reached limit, Removing bot!")
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
                tileSeed = 0
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] seeds Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] seeds Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.seed.world then
                print("All seeds storage has reached limit!")
                identity.botinfo("All seeds storage has reached limit! @everyone")
                identity.webhookinfo("All seeds storage has reached limit, Removing bot!")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
            tileSeed = 0
        end
    end
    infoid[world] = "["..identity.itemFloat(setting.item.seed).."]"
    if setting.mode.clearhistory then
        identity.randomworld(threads)
    end
    setJob(string.upper(setting.typeMode))
end

identity.storingblocks = function(threads)
    for i = index , #setting.storage.block.world do
        world = setting.storage.block.world[i]
        identity.door = setting.storage.block.door
        setJob("Dropping Blocks")
        identity.warp(world,identity.door)
        identity.webhookinfo("Dropping Blocks")
        if not nuked then
            if not wrong then
                if identity.itemFloat(setting.item.block) >= setting.storage.block.limit then
                    infoid[world] = "["..identity.itemFloat(setting.item.block).."] LIMIT !!!"
                    identity.botinfo("Blocks storage : [ ||"..getBot().world.."|| ] has reached limit, skipped world @everyone")
                    print("Blocks storage : [ "..getBot().world.." ] has reached limit, skipped world")
                    index = index + 1
                    if index > #setting.storage.block.world then
                        infoid[world] = "["..identity.itemFloat(setting.item.block).."] LIMIT !!!"
                        identity.botinfo("All blocks storage has reached limit, Removing bot : [ ||"..getBot().name.."|| ] slot : "..slot.." @everyone")
                        print("All blocks storage has reached limit, Removing bot : [ "..getBot().name.." ] slot : "..slot.." @everyone")
                        identity.webhookinfo("All blocks storage has reached limit, Removing bot!")
                        if setting.mode.removeBot then
                            removeBot(getBot().name)
                            sleep(100)
                        end
                        error()
                    end
                    tileBlock = 0
                else
                    for i,tile in pairs(getTiles()) do
                        if tile.fg == 0 or tile.bg == 0 then
                            ::BACK::
                            findPath(blockX + (tileBlock),blockY)
                            sleep(1000)
                            local count = 0
                            identity.reconnect(world,identity.door,blockX + (tileBlock),blockY)
                            if blockX + (tileBlock) >= 98 then
                                blockY = blockY - 1
                                tileBlock = 0
                            end
                            while findItem(setting.item.block) > 0 do
                                drop(setting.item.block)
                                sleep(setting.delay.drop)
                                identity.reconnect(world,identity.door,blockX + (tileBlock),blockY)
                                count = count + 1
                                if count >= 2 then
                                    tileBlock = tileBlock + 1
                                    goto BACK
                                end
                            end
                        end
                        if findItem(setting.item.block) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door blocks storage is wrong, check ur id door!")
                identity.botinfo("[ "..getBot().world.." ] Id door blocks storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.block.world then
                    print("All blocks storage has reached limit")
                    identity.botinfo("All blocks storage has reached limit @everyone")
                    identity.webhookinfo("All blocks storage has reached limit, Removing bot!")
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
                tileBlock = 0
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] blocks Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] blocks Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.block.world then
                print("All blocks storage has reached limit!")
                identity.botinfo("All blocks storage has reached limit! @everyone")
                identity.webhookinfo("All blocks storage has reached limit, Removing bot!")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
            tileBlock = 0
        end
    end
    infoid[world] = "["..identity.itemFloat(setting.item.block).."]"
    if setting.mode.clearhistory then
        identity.randomworld(threads)
    end
    setJob(string.upper(setting.typeMode))
end

identity.rechecking = function(threads)
    identity.webhookinfo("Re - checking worlds")
    for i = 1,2 do
        for _, tile in pairs(getTiles()) do
            if tile.fg == setting.item.seed and tile.ready then
                trees[threads] = ""..identity.scanTrees(setting.item.seed)..""
                if findItem(setting.item.support.items) == 0 then
                    if setting.item.support.access then
                        identity.support(threads)
                        
                        identity.door = identity.param
                        identity.warp(threads,identity.door)
                        identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                    end
                end
                if findItem(setting.item.block) > 180 then
                    if setting.item.recycle then
                        identity.recycles(threads)
                    else
                        identity.storingblocks(threads)
                        identity.door = identity.param
                        identity.warp(threads,identity.door)
                        identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                    end
                end
                if findItem(setting.item.event[1]) > setting.item.amount then
                    identity.storingevents(threads)
                    identity.door = identity.param
                    identity.warp(threads,identity.door)
                    identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                elseif findItem(setting.item.seed) > 180 then
                    identity.storingseeds(threads)
                    identity.door = identity.param
                    identity.warp(threads,identity.door)
                    identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                elseif findItem(112) > setting.pack.mingems then
                    identity.buying(threads)
                    identity.storingpacks(threads)
                    identity.door = identity.param
                    identity.warp(threads,identity.door)
                    identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                end
                identity.door = identity.param
                findPath(tile.x,tile.y)
                identity.reconnect(threads,identity.door,tile.x,tile.y)
                if tile.fg == setting.item.seed then
                    punch(0,0)
                    sleep(setting.delay.harvest)
                    identity.reconnect(threads,identity.door,tile.x,tile.y)
                end
                if setting.mode.ignoregems then
                    collect(setting.mode.range,112)
                else
                    collect(setting.mode.range)
                end
                sleep(25)
            end
        end
    end
    for _, obj in pairs(getObjects()) do
        if obj.id == setting.item.block then
            trees[threads] = ""..identity.scanTrees(setting.item.seed)..""
            if identity.itemFloat(setting.item.block) ~= 0 then
                findPath(identity.round(obj.x / 32),math.floor(obj.y / 32))
                if setting.mode.ignoregems then
                    collect(setting.mode.range,112)
                else
                    collect(setting.mode.range)
                end
                sleep(setting.delay.collect)
            end
            if findItem(setting.item.block) > 180 then
                if setting.item.recycle then
                    identity.recycles(threads)
                else
                    identity.storingblocks(threads)
                    identity.door = identity.param
                    identity.warp(threads,identity.door)
                    identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                end
            end
            if findItem(setting.item.event[1]) > setting.item.amount then
                identity.storingevents(threads)
                identity.door = identity.param
                identity.warp(threads,identity.door)
                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
            elseif findItem(setting.item.seed) > 180 then
                identity.storingseeds(threads)
                identity.door = identity.param
                identity.warp(threads,identity.door)
                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
            elseif findItem(112) > setting.pack.mingems then
                identity.buying(threads)
                identity.storingpacks(threads)
                identity.door = identity.param
                identity.warp(threads,identity.door)
                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
            end
        end
    end
    trees[threads] = ""..identity.scanTrees(setting.item.seed)..""
end

identity.running = function(threads)
    tileA = 99
    tileB = 0
    tileC = -1
    tileD = 0
    identity.webhookinfo("Type : "..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
    if setting.typeMode == "harvest" then
        if mode == "up" then
            for y = -1, 53 do
                for x = tileA, tileB, tileC do
                    if getTile(x,y).fg == setting.item.seed and getTile(x,y).ready then
                        trees[threads] = ""..identity.scanTrees(setting.item.seed)..""
                        if findItem(setting.item.support.items) == 0 then
                            if setting.item.support.access then
                                identity.support(threads)
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                            end
                        end
                        if findItem(setting.item.block) > 180 then
                            if setting.item.recycle then
                                identity.recycles(threads)
                            else
                                identity.storingblocks(threads)
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                            end
                        end
                        if findItem(setting.item.event[1]) > setting.item.amount then
                            identity.storingevents(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        elseif findItem(setting.item.seed) > 180 then
                            identity.storingseeds(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        elseif findItem(112) > setting.pack.mingems then
                            identity.buying(threads)
                            identity.storingpacks(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        end
                        identity.door = identity.param
                        findPath(x,y)
                        identity.reconnect(threads,identity.door,x,y)
                        if getTile(x,y).fg == setting.item.seed then
                            punch(0,0)
                            sleep(setting.delay.harvest)
                            identity.reconnect(threads,identity.door,x,y)
                        end
                        if setting.mode.ignoregems then
                            collect(setting.mode.range,112)
                        else
                            collect(setting.mode.range)
                        end
                        sleep(25)
                    end
                end
                if tileD == 1 then
                    if tileA == 0 then
                        tileA = 99
                        tileB = 0
                        tileC = -1
                        tileD = 0
                    elseif tileA == 99 then
                        tileA = 0
                        tileB = 99
                        tileC = 1
                        tileD = 0
                    end
                elseif tileD == 0 then
                    tileD = tileD + 1
                end
            end
        elseif mode == "down" then
            for y = 53, 0, -1 do
                for x = tileA, tileB, tileC do
                    if getTile(x,y).fg == setting.item.seed and getTile(x,y).ready then
                        trees[threads] = ""..identity.scanTrees(setting.item.seed)..""
                        if findItem(setting.item.support.items) == 0 then
                            if setting.item.support.access then
                                identity.support(threads)
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                            end
                        end
                        if findItem(setting.item.block) > 180 then
                            if setting.item.recycle then
                                identity.recycles(threads)
                            else
                                identity.storingblocks(threads)
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                            end
                        end
                        if findItem(setting.item.event[1]) > setting.item.amount then
                            identity.storingevents(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        elseif findItem(setting.item.seed) > 180 then
                            identity.storingseeds(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        elseif findItem(112) > setting.pack.mingems then
                            identity.buying(threads)
                            identity.storingpacks(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        end
                        identity.door = identity.param
                        findPath(x,y)
                        identity.reconnect(threads,identity.door,x,y)
                        if getTile(x,y).fg == setting.item.seed then
                            punch(0,0)
                            sleep(setting.delay.harvest)
                            identity.reconnect(threads,identity.door,x,y)
                        end
                        if setting.mode.ignoregems then
                            collect(setting.mode.range,112)
                        else
                            collect(setting.mode.range)
                        end
                        sleep(25)
                    end
                end
                if tileD == 1 then
                    if tileA == 0 then
                        tileA = 99
                        tileB = 0
                        tileC = -1
                        tileD = 0
                    elseif tileA == 99 then
                        tileA = 0
                        tileB = 99
                        tileC = 1
                        tileD = 0
                    end
                elseif tileD == 0 then
                    tileD = tileD + 1
                end
            end
        end
    elseif setting.typeMode == "collect" then
        if mode == "up" then
            for y = -1, 53 do
                for x = tileA, tileB, tileC do
                    if getTile(x, y).fg == 0 and getTile(x, y + 1).flags ~= 0 and identity.itemFloat(setting.item.block) ~= 0 then
                        trees[threads] = ""..identity.scanTrees(setting.item.seed)..""
                        if findItem(setting.item.support.items) == 0 then
                            if setting.item.support.access then
                                identity.support(threads)
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                            end
                        end
                        if findItem(setting.item.block) > 180 then
                            if setting.item.recycle then
                                identity.recycles(threads)
                            else
                                identity.storingblocks(threads)
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                            end
                        end
                        if findItem(setting.item.event[1]) > setting.item.amount then
                            identity.storingevents(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        elseif findItem(setting.item.seed) > 180 then
                            identity.storingseeds(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        elseif findItem(112) > setting.pack.mingems then
                            identity.buying(threads)
                            identity.storingpacks(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        end
                        identity.door = identity.param
                        findPath(x,y)
                        identity.reconnect(threads,identity.door,x,y)
                        if setting.mode.ignoregems then
                            collect(setting.mode.range,112)
                        else
                            collect(setting.mode.range)
                        end
                        sleep(25)
                    end
                end
                if tileD == 1 then
                    if tileA == 0 then
                        tileA = 99
                        tileB = 0
                        tileC = -1
                        tileD = 0
                    elseif tileA == 99 then
                        tileA = 0
                        tileB = 99
                        tileC = 1
                        tileD = 0
                    end
                elseif tileD == 0 then
                    tileD = tileD + 1
                end
            end
        elseif mode == "down" then
            for y = 53, 0, -1 do
                for x = tileA, tileB, tileC do
                    if getTile(x, y).fg == 0 and getTile(x, y + 1).flags ~= 0 and identity.itemFloat(setting.item.block) ~= 0 then
                        trees[threads] = ""..identity.scanTrees(setting.item.seed)..""
                        if findItem(setting.item.support.items) == 0 then
                            if setting.item.support.access then
                                identity.support(threads)
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                            end
                        end
                        if findItem(setting.item.block) > 180 then
                            if setting.item.recycle then
                                identity.recycles(threads)
                            else
                                identity.storingblocks(threads)
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                            end
                        end
                        if findItem(setting.item.event[1]) > setting.item.amount then
                            identity.storingevents(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        elseif findItem(setting.item.seed) > 180 then
                            identity.storingseeds(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        elseif findItem(112) > setting.pack.mingems then
                            identity.buying(threads)
                            identity.storingpacks(threads)
                            identity.door = identity.param
                            identity.warp(threads,identity.door)
                            identity.webhookinfo(""..string.upper(setting.typeMode).." mode : "..string.upper(mode).."")
                        end
                        identity.door = identity.param
                        findPath(x,y)
                        identity.reconnect(threads,identity.door,x,y)
                        if setting.mode.ignoregems then
                            collect(setting.mode.range,112)
                        else
                            collect(setting.mode.range)
                        end
                        sleep(25)
                    end
                end
                if tileD == 1 then
                    if tileA == 0 then
                        tileA = 99
                        tileB = 0
                        tileC = -1
                        tileD = 0
                    elseif tileA == 99 then
                        tileA = 0
                        tileB = 99
                        tileC = 1
                        tileD = 0
                    end
                elseif tileD == 0 then
                    tileD = tileD + 1
                end
            end
        end
    end
end

identity.scanTrees = function(threads)
    local count = 0
    for _, tile in pairs(getTiles()) do
        if tile.fg == threads and tile.ready then
            count = count + 1
        end
    end
    return count
end	

identity.support = function(threads)
    setJob("Take support items")
    world = identity.splitt(setting.item.support.world[index],"[^:]+")[1]
    identity.door = identity.splitt(setting.item.support.world[index],"[^:]+")[2]
    identity.warp(world,identity.door)
    identity.webhookinfo("Taking support items")
    if not nuked then
        if not wrong then
            if findItem(setting.item.support.items) == 0 and identity.itemFloat(setting.item.support.items) >= setting.item.support.keep then
                for _, obj in pairs(getObjects()) do
                    if obj.id == setting.item.support.items then
                        findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                        sleep(1000)
                        collect(setting.mode.range)
                        sleep(1000)
                        if findItem(setting.item.support.items) > 0  then
                            move(-1,0)
                            sleep(500)
                            wear(setting.item.support.items)
                            sleep(500)
                            drop(98,findItem(98) - 1)
                            sleep(500)
                            print("[ ||"..getBot().name.."|| ] slot : "..slot.." Success take and wear the support items!")
                            identity.botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." Success take and wear the support items!")
                            break
                        end
                    end
                end
            else
                print("Support item is empty, Drop the support item right now!")
                identity.botinfo("Support item is empty, Drop the support item right now! @everyone")
            end
        else
            print("Id door world take support items is wrong, check ur id door!")
            identity.botinfo("Id door world take support items is wrong, check ur id door! @everyone")
            error()
        end
    else
        print("World take support items is nuked, check ur world!")
        identity.botinfo("World take support items is nuked, check ur world! @everyone")
        error()
    end
end

if BizzantiuM.version == "1.0" and BizzantiuM.handler == "akbarsht" then
    sleep(math.random(1000,10000))
    for i = startfrom,#farmList do
        identity.door = identity.param
        setJob(string.upper(setting.typeMode))
        identity.warp(farmList[i],identity.door)
        identity.webhookinfo("Running script mode : "..string.upper(setting.typeMode).."")
        if not nuked then
            if not wrong then
                if setting.typeMode == "harvest" then
                    identity.running(farmList[i])
                    identity.rechecking(farmList[i])
                elseif setting.typeMode == "collect" then
                    identity.running(farmList[i])
                end
                timer[farmList[i]] = ""..identity.goodtimes(os.difftime(os.time(),identity.goodtime))..""
            else
                timer[farmList[i]] = "WRONG DOOR ID"
                trees[farmList[i]] = "WRONG DOOR ID"
                wrong = false
                sleep(1000)
                print(""..farmList[i].." is wrong door id, skipped world")
                identity.botinfo("[ ||"..farmList[i].."|| ] is wrong door id, skipped world @everyone")
            end
        else
            timer[farmList[i]] = "NUKED"
            trees[farmList[i]] = "NUKED"
            nuked = false
            sleep(1000)
            print(""..farmList[i].." is NUKED!, check ur world !!")
            identity.botinfo("[ ||"..farmList[i].."|| ] is NUKED!, check ur world !! @everyone")
        end
    end
end
print("[ "..getBot().name.." ] slot : "..slot.." Already finished all world, Terminated script!")
identity.botinfo("[ ||"..getBot().name.."|| ] slot : "..slot.." Already finished all world, Terminated script! @everyone")
if setting.mode.removeBot then
    removeBot(getBot().name)
    sleep(150)
end
error() 
